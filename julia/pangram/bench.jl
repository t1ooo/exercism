using BenchmarkTools

include("pangram.jl")

s1 = "Our story begins with two packages, Benchmarks and BenchmarkTrackers. The Benchmarks package implemented an execution strategy for collecting and summarizing individual benchmark results, while BenchmarkTrackers implemented a framework for organizing, running, and determining regressions of groups of benchmarks. Under the hood, BenchmarkTrackers relied on Benchmarks for actual benchmark execution. For a while, the Benchmarks + BenchmarkTrackers system was used for automated performance testing of Julia's Base library. It soon became apparent that the system suffered from a variety of issues: Individual sample noise could significantly change the execution strategy used to collect further samples. The estimates used to characterize benchmark results and to detect regressions were statistically vulnerable to noise (i.e. not robust). Different benchmarks have different noise tolerances, but there was no way to tune this parameter on a per-benchmark basis. Running benchmarks took a long time - an order of magnitude longer than theoretically necessary for many functions. Using the system in the REPL (for example, to reproduce regressions locally) was often cumbersome. The BenchmarkTools package is a response to these issues, designed by examining user reports and the benchmark data generated by the old system. BenchmarkTools offers the following solutions to the corresponding issues above: Benchmark execution parameters are configured separately from the execution of the benchmark itself. This means that subsequent experiments are performed more consistently, avoiding branching substrategies based on small numbers of samples. A variety of simple estimators are supported, and the user can pick which one to use for regression detection. Noise tolerance has been made a per-benchmark configuration parameter. Benchmark configuration parameters can be easily cached and reloaded, significantly reducing benchmark execution time. The API is simpler, more transparent, and overall easier to use."
s2 = "Наша история начинается с двух пакетов: ********** и *****************. Пакет ********** реализовал стратегию выполнения для сбора и обобщения результатов отдельных тестов, в то время как ***************** реализовал структуру для организации, запуска и определения регрессий групп тестов. Под капотом ***************** полагался на ********** для фактического выполнения тестов. Некоторое время система ********** ***************** использовалась для автоматического тестирования производительности библиотеки *****'* ****. Вскоре стало очевидно, что система страдает от множества проблем: шум отдельных образцов может значительно изменить стратегию выполнения, используемую для сбора следующих образцов. Оценки, использованные для характеристики результатов тестов и для обнаружения регрессий, были статистически уязвимы к шуму (т. Е. Ненадежны). Разные тесты имеют разные допуски на шум, но не было возможности настраивать этот параметр для каждого теста. Выполнение тестов заняло много времени - на порядок больше, чем теоретически необходимо для многих функций. Использование системы в **** (например, для локального воспроизведения регрессий) часто было обременительным. Пакет ************** - это ответ на эти проблемы, разработанный путем изучения отчетов пользователей и данных тестов, созданных старой системой. ************** предлагает следующие решения соответствующих проблем, описанных выше: Параметры выполнения теста настраиваются отдельно от выполнения самого теста. Это означает, что последующие эксперименты проводятся более последовательно, избегая ветвления субстратов на основе небольшого количества образцов. Поддерживается множество простых оценщиков, и пользователь может выбрать, какой из них использовать для обнаружения регрессии. Шумостойкость была сделана параметром конфигурации каждого теста. Параметры конфигурации теста можно легко кэшировать и перезагружать, что значительно сокращает время выполнения теста. *** проще, прозрачнее и в целом проще в использовании."


function bench1(f)
    print("bench1:", Symbol(f))
    @btime $f(s1)
end

function bench2(f)
    print("bench2:", Symbol(f))
    @btime $f(s2)
end

bench1(ispangram)
bench1(ispangram1)
bench1(ispangram2)
bench1(ispangram3)
bench1(ispangram4)
println("----------")

bench2(ispangram)
bench2(ispangram1)
bench2(ispangram2)
bench2(ispangram3)
bench2(ispangram4)
println("----------")

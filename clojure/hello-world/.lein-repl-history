(+ 1 2)
(hello)
(require 'hello-wolrd')
(require 'hello-world')
(require hello-world)
(help)
(require hello-world-test)
(require 'hello-world-test')
(println "Hello World")
(require 'hello-world)
(hello)
(hello-world::hello)
(hello-world/hello)
:r
(require 'hello-world)
(hello-wolrd t)
(hello-wolrd/t)
(hello-world/t)
(require 'hello-world)
(hello-world/fun)
(hello-world/hello)
(hello-world/fun)
(require '[clojure.repl :refer :all])
(doc nil?)
(source some?)
(require 'hello-world :reload)
(hello-world/fun)
(doc 'hello-world)
(doc hello-world)
(source hello-world)
(show hello-world)
(show 'hello-world)
(keys (ns-publics 'hello-world))
(keys 'hello-world)
(keys (ns 'hello-world))
(keys (ns-private 'hello-world))
(keys (ns-publics 'hello-world))
(dir 'hello-world)
(dir hello-world)
(dir 'hello-world)
(apropos "index")
(find-doc "indexed")
(str "Hello" " " "World") 
(str "Hello" "  " "World") 
(class 1)
(hello-world/fun)
(require 'hello-world :reload)
(hello-world/fun)
(require 'hello-world :reload)
(hello-world/fun)
(require 'hello-world :reload)
(hello-world/fun)
(eval '(+ 1 2))
(typeof 1)
(type-of 1)
(type 1)
(type '(1 2 3))
(type #(1 2 3))
(type [1 2 3])
(type (1 2 3))
(type coll)
(doc coll?)
(source coll?)
(range 4)
(type range 4)
(type (range 4))
(take 4 (range))
(cons 4 [1 2 3])
(type (cons 4 [1 2 3]))
(type (cons 4 '(1 2 3)))
(type (cons 4 [1 2 3]))
(type (cons 4 '(1 2 3)))
(let (cons 4 '(1 2 3)))
(let [x (cons 4 '(1 2 3))] (type x))
(type (eval (cons 4 [1 2 3])))
(eval (cons 4 [1 2 3]))
(eval '(cons 4 [1 2 3]))
(type (eval '(cons 4 [1 2 3])))
(conj [1 2 3] 4)
(concat [1 2] '(3 4))
(concat [1 2] [3 4])
(map inc [1 2 3])
(filter even? [1 2 3])
(reduce + [1 2 3 4])
(map (+1) [1 2 3])
(map (1 +) [1 2 3])
(reduce conj [] '(3 2 1))
(reduce cons [] '(3 2 1))
(reduce conj [] '(3 2 1))
(reduce cons [] '(3 2 1))
(source cons)
(source conj)
(def x 1)
x
(x)
x
(def hello2 #(str "Hello " %1))
hello2
(hello2)
(hello2 1)
{:a 1 :b 2 :c 3}
({:a 1 :b 2 :c 3})
(type {:a 1 :b 2 :c 3})
({:a 1 :b 2 :c 3}[:a])
({:a 1 :b 2 :c 3}[a])
({:a 1 :b 2 :c 3} a)
({:a 1 :b 2 :c 3} :a)
(:A {:a 1 :b 2 :c 3})
(:a {:a 1 :b 2 :c 3})
({"a" 1 "b" 2} "a")
("a" {"a" 1 "b" 2})
(assoc {:a 1} :d 4)
(type #{1 2 3})
(set [1 2 3])
(list [1 2 3])
(source list)
(vector [1 2 3])
(vector 1)
(vector 1 2 3)
(list 1 2 3)
(set 1 2 3)
(conj #{1 2 3} 4)
(disj #{1 2 3} 1)
(disj [1 2 3] 1)
(disj '(1 2 3) 1)
(conj #{1 2 3} 4)
(conj [1 2 3] 4)
(source disj)
(if false "a")
(let [a 1 b 2]
  (> a b)) 
a
(let [a 1 b 2] (a+b))
(let [a 1 b 2] (+ a b))
(let [a 1, b 2] (+ a b))
(let [a 1; b 2] (+ a b))
;
)
(let [a 1, b 2] (+ a b))
[1,2,3,4]
(do "123")
source do
(source do)
(let [name "Urkel"]
  (print "Saying hello to " name)
  (str "Hello " name))
(->  
   {:a 1 :b 2} 
   (assoc :c 3) ;=> (assoc {:a 1 :b 2} :c 3)
   (dissoc :b))
(-> 123 (str))
(-> 123 (+))
(-> 123 (+) 356)
(-> 123 (+ 356))
(-> 123 (+ 356) (+ 3456))
(->> 123 (+ 356) (+ 3456))
(-> (range 10) (map inc))
(->> (range 10) (map inc))
(as-> (range 10) x (map inc x))
(as-> ((range 10) x) (map inc x))
(as-> (range 10) x (map inc x))
(intersection #{1 2 3} #{2 3 4}) 
(dir clojure.set)
(source intersection)
(source clojure.set/intersection)
(source use)
(source require)
(clojure.string/blank? "")
(clojure.set/intersection #{1 2} #{2 3})
(doc import java.util.Date)
(import java.util.Date)
(doc java.util.Date)
(source java.util.Date)
(Date.) 
(. (Date.) getTime)
(doto (java.util.HashMap.)
      (.put "a" 1)
      (.put "b" 2)
      (println))
(doc swap!)
:reload
(use 'hello-world :reload)
(require 'hello-world :reload)
(require 'hello-world :reload-all)
(hello-world/fun)
(defmacro my-first-macro []
  (list reverse "Hello World"))
(macroexpand '(my-first-macro))
(eval (macroexpand '(my-first-macro)))
(my-first-macro)
(defmacro my-first-quoted-macro []
  '(reverse "Hello World"))
(macroexpand '(my-first-quoted-macro))
(defmacro inc2 [arg]
  (list + 2 arg))
(inc2 2)
(macroexpand '(my-first-quoted-macro))
(defmacro inc2 [arg]
  (list + 2 arg))
(inc2 2)
(inc2 23)
(defmacro inc2 [arg] (+2 arg)
)
(inc2 23)
(defmacro inc2-quoted [arg] `(+ 2 ~arg))
(inc2-quoted 2)
(defmacro inc2-quoted [arg] `(+ 2 arg))
(inc2-quoted 2)
(defmacro inc2-quoted [arg] `(+ 2 ~arg))
(inc2-quoted 2)
(def reload (require 'hello-world :reload-all))
(defn reload (require 'hello-world :reload-all))
(def reload #(require 'hello-world :reload-all))
(reload)
(defn reload [] (require 'hello-world :reload-all))
reload
(reload)
(defn r [] (require 'hello-world :reload-all))
(r)
(map int [1 2 3])
(map inc [1 2 3])
(map float [1 2 3])
(map (lambda (x) (+ 1 x)) [1 2 3])
(map (fn (x) (+ 1 x)) [1 2 3])
(map (fn [x] (+ 1 x)) [1 2 3])
(map (fn [x] require 'x :reload-all) [hello-world])
(map (fn [x] require x :reload-all) ['hello-world])
(hello-world/fun2)
(map (fn [x] require x :reload-all) ['hello-world])
(hello-world/fun2)
(map (fn [x] require x :reload-all) ['hello-world])
(hello-world/fun2)
(map (fn [x] (require x :reload-all)) ['hello-world])
(hello-world/fun2)
(refresh)
(use '[clojure.tools.namespace.repl :only (refresh)])
(require '[clojure.tools.namespace.repl :refer [refresh]])
(defn rs [nss] (map (fn [x] (require x :reload-all)) nss))
(defn r [] (rs ['hello-world])
)
(r)
(hello-world/fun2)
(r)
(hello-world/fun2)
(clojure.test/run-tests 'bob-test)
(hello-world.test/run-tests 'bob-test)
(require 'hello-world-test)
(hello-world-test/run-test)
(hello-world-test/hello-world-test)
(r)
(hello-world-test/hello-world-test)
(r)
(hello-world-test/hello-world-test)
(quit)
